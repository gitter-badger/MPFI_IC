"""Collection of useful methods for interacting with ScanImage tif files generated by ScanImage2015.

Todo:
    Support multiple versions of scanimage
"""

import json
from collections import defaultdict
from pathlib import Path

import numpy as np
from PIL import Image
import skimage.io as io


def read_si_tiffstack(path_name: str, header_only: bool = False) -> tuple:
    """Open a scanimage tiff file

    Reads header data using PIL and tiff image data using scikit-image. 

    Todo:
        Using two libraries is inefficient, finding a single solution would be the best.

    Args:
        path_name (str): Path to a tif file
        header_only (bool): flag to parse header only and return no image data
    Returns:
        tuple: Image Data (numpy.ndarray (z,y,x)), header (dict)
    """

    # convert any windows style
    if not isinstance(path_name, Path):
        file_to_open = Path(path_name)
    else:
        file_to_open = path_name
    assert file_to_open.exists(), 'File does not exist!'

    img = Image.open(file_to_open)
    header = parse_si_header(img.tag.tagdata)
    if not header_only:
        img_data = io.imread(file_to_open)
    else:
        img_data = None
    return img_data, header


def parse_si_header(header) -> dict:
    """Cleans ScanImage header information into a useable format.

    Args:
        header (str or dict): ScanImage header information

    Returns:
        dict: ScanImage header information as a useable dict.
    """

    assert isinstance(header, str) or isinstance(header, dict), 'Please provide a str or dict!'
    if isinstance(header, str):
        return _parse_string(header)
    elif isinstance(header, dict):
        return _parse_dict(header)
    return None


def to_json(header: dict, filename: str):
    """Writes header information into a json file
    Args:
        header (dict): ScanImage header as a dictionary.
        filename (str): Filepath to write to.
    """

    with open(filename, 'w') as fid:
        json.dump(header, fid)


def _parse_dict(header: dict) -> dict:
    """ Parse Scanimage header from dict_input.

    Pulls the Scanimage headings from tiff tags which returned as a dict_input. One of the values in the dict_input 
    should be a Scanimage header as a string. Returns None if a header can not be found.

    Args:
        header (dict): Scanimage header in a dict_input.

    Returns:
        dict: Parsed ScanImage header.
    """

    for entry in header.values():
        if b'SI' in entry:
            return _parse_string(entry.decode('ASCII'))
    return None


def _parse_string(header: str)->dict:
    """ Parse Scanimage header from string.

    Parses a string which contains Scanimage header data. Each line is a different property (broken by the newline). 
    If no information can be parsed from the string, it will return None.

    Args:
        header (str): Scanimage header as a string.

    Returns:
        dict: Scanimage header as a dict
    """
    header_parsed = dict()
    for row in header.split('\n'):

        row_entries = row.split('=')
        if len(row_entries) > 1:
            rowKeys = row_entries[0]
            rowVal = row_entries[1]
            row_dict = _recursive_key(header_parsed, rowKeys.split('.'), rowVal.strip())
            header_parsed = {**header_parsed, **row_dict}

    return header_parsed if header_parsed else None


def _recursive_key(dict_input, keylist, value):
    if len(keylist) == 1:
        dict_input[keylist[0].strip()] = value
        return dict_input
    if keylist[0] not in dict_input.keys():
        dict_input[keylist[0].strip()] = dict()
    dict_input[keylist[0].strip()] = _recursive_key(dict_input[keylist[0]], keylist[1:], value)
    return dict_input


def si_version(header: dict):
    """Returns SI version.

    Todo:
        Parse header dict for ScanImage version
    Args:
        header (dict): Header information as dict
    """
    return header['scanimage']['SI']['VERSION_MAJOR']


def piezo_slices(header: dict) -> int:
    """Reads ScanImage header and returns the number of z slices.
    Args:
        header (dict): ScanImage header

    Raises:
        ValueError: Raised if ScanImage headers are not 2015.

    Returns:
        int: Number of piezo planes.
    """

    if si_version(header) == '2015':
        if header['scanimage']['SI']['hFastZ']['enable'] is 1:
            return int(header['scanimage']['SI']['hFastZ']['numFramesPerVolume'])
        else:
            return 1
    else:
        raise ValueError('Only parsing for Scanimage 2015 is available at the moment')


def channels(header: dict)-> np.array:
    """Returns a list of active channels acquired.

    Args:
        header (dict): ScanImage header information.

    Raises:
        ValueError: Raised if ScanImage headers are not 2015

    Returns:
        np.array: List of active channels.
    """

    if si_version(header) == '2015':
        channel_list = header['scanimage']['SI']['hChannels']['channelSave']
        channel_list = ''.join(x for x in channel_list if x not in '[]')
        return np.fromstring(channel_list, dtype=int, sep=';')
    else:
        raise ValueError('Only parsing for Scanimage 2015 is available at the moment')


def frames_per_file(header: dict) -> int:
    """Returns the frames logged per file from ScanImage header.

    Args:
        header (dict): ScanImage header

    Raises:
        ValueError: Raised if ScanImage headers are not 2015

    Returns:
        int: Number of frames per file.
    """

    if si_version(header) == '2015':
        return int(header['scanimage']['SI']['hResScan']['logFramesPerFile'])
    else:
        raise ValueError('Only parsing for Scanimage 2015 is available at the moment')
